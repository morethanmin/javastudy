# 목표

자바의 Class에 대해 학습하세요.

# 학습할 것 (필수)

-   클래스 정의하는 방법
-   객체 만드는 방법 (new 키워드 이해하기)
-   메소드 정의하는 방법
-   생성자 정의하는 방법
-   this 키워드 이해하기

# 마감일시

2020년 12월 19일 토요일 오후 1시까지.

# 과제 (Optional)

-   int 값을 가지고 있는 이진 트리를 나타내는 Node 라는 클래스를 정의하세요.
-   int value, Node left, right를 가지고 있어야 합니다.
-   BinrayTree라는 클래스를 정의하고 주어진 노드를 기준으로 출력하는 bfs(Node node)와 dfs(Node node) 메소드를 구현하세요.
-   DFS는 왼쪽, 루트, 오른쪽 순으로 순회하세요.

# 0. 개념

## 클래스

클래스는 객체를 만들기 위한 모형이면서 틀이다. (template) 객체를 만들기 위해서는 반드시 어떠한 클래스가 필요하게된다. 클래스는 속성과 행동으로 구성되어 있다.

## 객체

그렇다면 객체는 무엇일까? 객체는 클래스의 하나의 구체적인 실례라고 할수있다. **(instance)**

객체와 클래스를 붕어빵집으로 예를 자주드는데, 클래스는 붕어빵을 찍어내는 빵 틀이고, 이로인해 만들어진 붕어빵이 객체라고 할 수 있다.

이러한 클래스를 정의하기 전에 클래스에 대한 다양한 개념들을 정리해보자

## 추상화

추상화(abstraction)는 클래스를 이용해 현실세계에 있는 객체에서 불필요한 부분은 없애고 이러한 객체드를 추상적으로 하여 클래스를 만드는 작업을 말한다.

## 캡슐화

캡슐화(encapsulation)는 객체와 객체 간의 필요한 정보만 노출하는 것을 캡슐화라고 한다. 클래스를 사용하는 사람은 클래스 내부가 어떻게 돌아가는지 까지 알 필요는 없기 때문이다. 이 과정에서 정보 은닉(information hiding)이 발생하게 된다.

## 상속
상속은 객체지향의 핵심이 되는 개념으로 상위 클래스와 이를 물려받는 하위클래스가 존재하게 되는 개념이다.

## 다형성

외부에서 보이는 모습은 같은 형태이지만 실질적으로 다른 기능의 역할을 수행하는 경우를 다형성이라고 말한다. 다형성의 예로는 오버로딩(overloading)과 오버라이딩(overriding)이 있다.

## 필드 지정자

필드(클래스, 변수, 메소드)를 지정할때는 다양한 필드 지정자를 앞에 표기해야 한다.

사진

### final

#### 클래스와 final

클래스에 final을 붙이게 되면 final 클래스는 자식 클래스를 가질 수 없게된다.

#### 변수와 final

변수에 final을 붙이게 되면 선언할때 딱 한번만 초기화가 가능하고 이후에는 값을 변경할 수 없게된다.
또한 값이 변경되지 않기 때문에 static과 함께 사용해야 같은 변수가 여러개 생성되지 않을 수 있다.

#### 메소드와 final

메소드도 클래스와 마찬가지로 상속 구조에서 부모 클래스의 매소드에 final을 붙이게 되면 자식 클래스에서 동일한 모양의 메소드를 재정의(overriding) 할 수 없게된다.

### 접근 지정자 (public, protected, private)

접근 지정자는 필드의 참조권한의 범위를 지정하는 지정자이다.

사진

### static

#### 클래스와 static

#### 변수와 static

static을 사용하지 않을 땐, 생성된 객체마다 각각의 변수가 생성된다.
static을 사용하게 되면 많은 객체를 생성하게 되더라도 메모리에 static으로 선언된 변수 하나만 존재한다. 따라서 클래스로부터 생성되는 모든 객체는 하나의 클래스 변수를 공유하게 된다.

또한 객체를 생성하지 않더라도 클래스의 이름을 통해 접근이 가능하다.
이 말은 객체가 생성될 때 메모리 공간을 할당하는 것이 아니라, 클래스가 로딩될때 메모리에 한번만 할당되는 것이다.

#### 메소드와 static

메소드도 변수와 마찬가지로 따로 객체를 생성하지 않더라도 속해있는 클래스가 선언될 때 선언되기 때문에 클래스를 통해 메소드를 호출할 수 있다. 이때 주의해야 할 것은 객체가 선언될 때 사용하는 변수는 객체를 생성했을 때 메모리가 잡히므로 static 메소드에서 사용이 불가능하다.



필드를 선언할 때 초기 값이 없을 경우 저장되는 기본 값은 다음과 같다.

사진


# 1. 클래스 정의하는 방법

## 클래스의 필드 생성

클래스의 필드는 다음과 같이 구현(정의)한다.

```java
public class exampleClass {
    public long number;
    public String name;
}

```

# 2. 객체 만드는 방법 (new 키워드 이해하기)

클래스는 객체를 만드는 모형이고 객체는 클래스로부터 만들어진다고 배웠다. 객체를 만드는 방법은 다음과 같이 new 키워드를 사용해 만든다. new 이후에는 생성자(constructor)를 호출한다.

```
클래스명 객체명 = new 생성자();
```

```java
exampleClass A = new A();
```

## 3. 메소드 정의하는 방법

클래스에서 메소드를 구현하는 방식은 다음과 같다.
```
지정자 반환형 메소드이름(매게변수) { 명령문 }
```

또한 구현이 없는 추상 메소드를 지정할 때에는 **abstract**를 사용하고, 다중 스레드에서 메소드 동기화를 지정하는 경우에는 **synchronized**를 사용한다.

## 4. 생성자 정의하는 방법

생성자는 객체가 생성 될 때 필요한 작업을 수행하도록 도와주는 특별한 메소드로 초기 값을 저장하거나 초기화 작업을 수행하기 위해 사용되는 메소드다. 따라서 반환형을 적지 않고 이름은 클래스 이름이여야한다.

다음과같은 형식으로 이루어져 있다.

```
지정자 클래스이름(매게변수) {명령}
```

클래스에 생성자가 구현되지 않았을 땐 인자가 없는 기본 생성자를 자동으로 제공해 준다.
만약 인자가 있는 생성자를 구현했다면 기본 생성자는 사용이 불가능 하므로 기본 생성자도 직접 구현해야한다.

또한 하나의 클래스에서 인자가 다른 생성자를 여러개 구현가능한데 이를 생성자 오버로딩 이라고 한다.

```java
public class car{
    public int name;
    public car();
    public car(String name){
        this.name = name;
    }
}
```

## 5. this 키워드 이해하기

this 키워드는 클래스가 객체로 선언되었을 때 자기 자신의 주소를 담고있는 키워드를 말한다.

또한 클래스 내부에서 this()를 호출하게 되면 생성자를 호출한다. 이때 몇가지 제약이 있는데 생성자 에서만 호출이 가능하며 가장 첫 문장에서 호출해야하고, 마지막으로 재귀호출은 불가능하다,